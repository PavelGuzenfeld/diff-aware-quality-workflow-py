name: CIS Org Compliance

on:
  workflow_call:
    inputs:
      org:
        type: string
        required: true
        description: 'GitHub org or user to scan'
      repos:
        type: string
        default: ''
        description: 'Comma-separated repo names to scan (empty = all non-archived repos)'
      max_repos:
        type: number
        default: 100
        description: 'Maximum number of repos to scan (controls runtime)'
      active_months:
        type: number
        default: 6
        description: 'Only scan repos pushed to within this many months (0 = all repos)'
      min_score:
        type: number
        default: 0
        description: 'Minimum passing score per repo (0-35). 0 = report only.'
      chain_bench_version:
        type: string
        default: '0.1.10'
        description: 'chain-bench version to install'
      create_tracking_issue:
        type: boolean
        default: false
        description: 'Create/update a tracking issue in the .github repo with results'
      runner:
        type: string
        default: '"ubuntu-latest"'
        description: 'Runner labels as JSON'
    secrets:
      app_id:
        required: false
        description: 'GitHub App ID with org-level read permissions'
      app_private_key:
        required: false
        description: 'GitHub App private key (PEM)'
      scan_token:
        required: false
        description: 'GitHub token with repo + read:org scope (fallback if no App)'

permissions:
  contents: read
  issues: write

jobs:
  cis-scan:
    name: CIS SSC Org Scan
    runs-on: ${{ fromJSON(inputs.runner) }}
    steps:
      - name: Check for App credentials
        id: app-check
        env:
          HAS_APP: ${{ secrets.app_id != '' && secrets.app_private_key != '' }}
        run: echo "has_app=$HAS_APP" >> "$GITHUB_OUTPUT"

      - name: Generate GitHub App token
        if: steps.app-check.outputs.has_app == 'true'
        id: app-token
        uses: actions/create-github-app-token@29824e69f54612133e76f7eaac726eef6c875baf # v2
        with:
          app-id: ${{ secrets.app_id }}
          private-key: ${{ secrets.app_private_key }}
          owner: ${{ inputs.org }}

      - name: Detect architecture
        id: arch
        run: |
          case "$(uname -m)" in
            x86_64)  echo "suffix=Linux-64bit" >> "$GITHUB_OUTPUT" ;;
            aarch64) echo "suffix=Linux-ARM64" >> "$GITHUB_OUTPUT" ;;
            *)       echo "suffix=Linux-64bit" >> "$GITHUB_OUTPUT" ;;
          esac

      - name: Install chain-bench
        run: |
          VERSION="${{ inputs.chain_bench_version }}"
          SUFFIX="${{ steps.arch.outputs.suffix }}"
          URL="https://github.com/aquasecurity/chain-bench/releases/download/v${VERSION}/chain-bench_${VERSION}_${SUFFIX}.tar.gz"
          echo "Downloading chain-bench v${VERSION} for ${SUFFIX}..."
          curl -sL "$URL" -o /tmp/chain-bench.tar.gz
          tar -xzf /tmp/chain-bench.tar.gz -C /tmp chain-bench
          chmod +x /tmp/chain-bench
          /tmp/chain-bench --version || echo "chain-bench installed"

      - name: Discover repos
        id: discover
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token || secrets.scan_token || github.token }}
        run: |
          ORG="${{ inputs.org }}"
          EXPLICIT="${{ inputs.repos }}"
          MAX="${{ inputs.max_repos }}"
          ACTIVE_MONTHS="${{ inputs.active_months }}"

          # Compute cutoff date for active repos filter
          CUTOFF=""
          if [ "$ACTIVE_MONTHS" -gt 0 ] 2>/dev/null; then
            CUTOFF=$(date -u -d "${ACTIVE_MONTHS} months ago" '+%Y-%m-%dT%H:%M:%SZ')
            echo "Activity filter: repos pushed after ${CUTOFF} (last ${ACTIVE_MONTHS} months)"
          fi

          if [ -n "$EXPLICIT" ]; then
            # Use explicit list
            REPOS=""
            IFS=',' read -ra ITEMS <<< "$EXPLICIT"
            for ITEM in "${ITEMS[@]}"; do
              ITEM=$(echo "$ITEM" | xargs)  # trim whitespace
              if [[ "$ITEM" != */* ]]; then
                ITEM="${ORG}/${ITEM}"
              fi
              REPOS="${REPOS}${ITEM}"$'\n'
            done
          else
            # Auto-discover: all non-archived, non-fork repos
            # Try org endpoint first, fall back to user endpoint
            REPOS=""
            JQ_FILTER='.[] | select(.archived == false and .fork == false)'
            if [ -n "$CUTOFF" ]; then
              JQ_FILTER="${JQ_FILTER} | select(.pushed_at > \"${CUTOFF}\")"
            fi
            JQ_FILTER="${JQ_FILTER} | .full_name"

            if CANDIDATE=$(gh api --paginate "/orgs/${ORG}/repos?type=sources&per_page=100" \
              --jq "$JQ_FILTER" 2>/dev/null); then
              REPOS="$CANDIDATE"
            fi
            if [ -z "$REPOS" ]; then
              if CANDIDATE=$(gh api --paginate "/users/${ORG}/repos?type=sources&per_page=100" \
                --jq "$JQ_FILTER" 2>/dev/null); then
                REPOS="$CANDIDATE"
              fi
            fi

            # Apply max_repos limit
            REPOS=$(echo "$REPOS" | head -n "$MAX")
          fi

          # Write repo list to file
          echo -n "$REPOS" | grep -v '^$' > /tmp/repo-list.txt || true
          TOTAL=$(wc -l < /tmp/repo-list.txt)
          echo "count=$TOTAL" >> "$GITHUB_OUTPUT"
          echo ""
          echo "Discovered ${TOTAL} repos to scan"

      - name: Write log parser script
        run: |
          cat > /tmp/parse-cis-log.py << 'PYEOF'
          import re, json, sys
          log_file, json_file = sys.argv[1], sys.argv[2]
          results = []
          with open(log_file) as f:
              for line in f:
                  clean = re.sub(r'\x1b\[[0-9;]*m', '', line).strip()
                  m = re.match(r'^(\d+\.\d+\.\d+)\s+(.+?)\s+(Passed|Failed|Unknown)\s*(.*)', clean)
                  if m:
                      rid, name, result, reason = m.groups()
                      entry = {'id': rid, 'name': name.strip(), 'result': result}
                      if reason.strip():
                          entry['reason'] = reason.strip()
                      results.append(entry)
          if results:
              out = {'results': results}
              with open(json_file, 'w') as f:
                  json.dump(out, f)
              print(f'  Parsed {len(results)} controls from log')
          else:
              print('  No controls found in log')
          PYEOF

      - name: Scan repos
        id: scan
        env:
          SCAN_TOKEN: ${{ steps.app-token.outputs.token || secrets.scan_token || github.token }}
          GH_TOKEN: ${{ steps.app-token.outputs.token || secrets.scan_token || github.token }}
        run: |
          mkdir -p /tmp/cis-results

          SCAN_COUNT=0

          while IFS= read -r REPO; do
            [ -z "$REPO" ] && continue
            REPO_SHORT="${REPO##*/}"
            REPO_URL="https://github.com/${REPO}"

            # Check rate limit before each scan (chain-bench uses ~50-100 API calls per repo)
            REMAINING=$(gh api rate_limit --jq '.rate.remaining' 2>/dev/null || echo "999")
            if [ "$REMAINING" -lt 100 ]; then
              RESET=$(gh api rate_limit --jq '.rate.reset' 2>/dev/null || echo "0")
              NOW=$(date +%s)
              WAIT=$(( RESET - NOW + 5 ))
              if [ "$WAIT" -gt 0 ] && [ "$WAIT" -lt 3600 ]; then
                echo ""
                echo "  Rate limit low (${REMAINING} remaining). Waiting ${WAIT}s for reset..."
                sleep "$WAIT"
              else
                echo ""
                echo "  Rate limit exhausted (${REMAINING} remaining). Skipping remaining repos."
                break
              fi
            fi

            # Get default branch (guard against error JSON leaking into variable)
            DEFAULT_BRANCH="main"
            if BRANCH=$(gh api "repos/${REPO}" --jq '.default_branch' 2>/dev/null); then
              [ -n "$BRANCH" ] && DEFAULT_BRANCH="$BRANCH"
            fi

            echo ""
            echo "═══════════════════════════════════════"
            echo "  Scanning: ${REPO} (branch: ${DEFAULT_BRANCH})"
            echo "═══════════════════════════════════════"

            /tmp/chain-bench scan \
              --repository-url "$REPO_URL" \
              --branch "$DEFAULT_BRANCH" \
              --access-token "$SCAN_TOKEN" \
              --output-file "/tmp/cis-results/${REPO_SHORT}.json" \
              2>&1 | tee "/tmp/cis-results/${REPO_SHORT}.log" || true

            # Debug: check JSON output
            if [ -f "/tmp/cis-results/${REPO_SHORT}.json" ] && [ -s "/tmp/cis-results/${REPO_SHORT}.json" ]; then
              echo "  JSON output: $(wc -c < "/tmp/cis-results/${REPO_SHORT}.json") bytes"
            else
              echo "  JSON output: empty or missing — will parse from log"
              # Generate JSON from log output using the Passed/Failed/Unknown markers
              python3 /tmp/parse-cis-log.py "/tmp/cis-results/${REPO_SHORT}.log" "/tmp/cis-results/${REPO_SHORT}.json" 2>/dev/null || echo "  Log parsing failed"
            fi

            SCAN_COUNT=$((SCAN_COUNT + 1))

          done < /tmp/repo-list.txt
          echo ""
          echo "Scanned ${SCAN_COUNT} repos"

      - name: Generate org dashboard
        id: dashboard
        if: always()
        run: |
          touch /tmp/repo-list.txt
          MIN_SCORE="${{ inputs.min_score }}"
          ORG="${{ inputs.org }}"
          WORST_SCORE=999
          TOTAL_PASSED=0
          TOTAL_CHECKS=0
          REPO_COUNT=0
          FAILING_REPOS=""

          # --- Summary table ---
          {
            echo "## CIS Software Supply Chain v1.0 — ${ORG}"
            echo ""
            echo "### Summary"
            echo ""
            echo "| Repo | Passed | Failed | Unknown | Score | Status |"
            echo "|:-----|:------:|:------:|:-------:|:-----:|:------:|"
          } > /tmp/cis-dashboard.md

          # Collect all unique control IDs across repos for the matrix
          ALL_IDS_FILE="/tmp/cis-all-ids.txt"
          > "$ALL_IDS_FILE"

          while IFS= read -r REPO; do
            [ -z "$REPO" ] && continue
            REPO_SHORT="${REPO##*/}"
            RESULT_FILE="/tmp/cis-results/${REPO_SHORT}.json"

            PASSED=0; FAILED=0; UNKNOWN=0

            if [ -f "$RESULT_FILE" ] && [ -s "$RESULT_FILE" ]; then
              PASSED=$(jq '[.results[] | select(.result == "Passed")] | length' "$RESULT_FILE" 2>/dev/null) || PASSED=0
              FAILED=$(jq '[.results[] | select(.result == "Failed")] | length' "$RESULT_FILE" 2>/dev/null) || FAILED=0
              UNKNOWN=$(jq '[.results[] | select(.result == "Unknown")] | length' "$RESULT_FILE" 2>/dev/null) || UNKNOWN=0
              # Collect control IDs
              jq -r '.results[] | .id' "$RESULT_FILE" 2>/dev/null >> "$ALL_IDS_FILE" || true
            fi

            TOTAL=$((PASSED + FAILED + UNKNOWN))
            [ "$TOTAL" -eq 0 ] && TOTAL=35

            PERCENT=0
            [ "$TOTAL" -gt 0 ] && PERCENT=$((PASSED * 100 / TOTAL))

            STATUS="—"
            if [ "$MIN_SCORE" -gt 0 ]; then
              if [ "$PASSED" -ge "$MIN_SCORE" ]; then
                STATUS="PASS"
              else
                STATUS="FAIL"
                FAILING_REPOS="${FAILING_REPOS}${REPO} (${PASSED}/${TOTAL})\n"
              fi
            fi

            echo "| ${REPO_SHORT} | ${PASSED} | ${FAILED} | ${UNKNOWN} | ${PERCENT}% | ${STATUS} |" >> /tmp/cis-dashboard.md

            TOTAL_PASSED=$((TOTAL_PASSED + PASSED))
            TOTAL_CHECKS=$((TOTAL_CHECKS + TOTAL))
            REPO_COUNT=$((REPO_COUNT + 1))
            [ "$PASSED" -lt "$WORST_SCORE" ] && WORST_SCORE=$PASSED

          done < /tmp/repo-list.txt

          # Summary stats
          AVG_PERCENT=0
          [ "$TOTAL_CHECKS" -gt 0 ] && AVG_PERCENT=$((TOTAL_PASSED * 100 / TOTAL_CHECKS))

          {
            echo ""
            echo "**Repos scanned:** ${REPO_COUNT} | **Org average:** ${AVG_PERCENT}%"
            if [ "$MIN_SCORE" -gt 0 ]; then
              echo "**Minimum threshold:** ${MIN_SCORE}/35"
            fi
          } >> /tmp/cis-dashboard.md

          # --- Detailed per-repo breakdown ---
          while IFS= read -r REPO; do
            [ -z "$REPO" ] && continue
            REPO_SHORT="${REPO##*/}"
            RESULT_FILE="/tmp/cis-results/${REPO_SHORT}.json"

            {
              echo ""
              echo "---"
              echo ""
            } >> /tmp/cis-dashboard.md

            # Compute per-repo stats for the heading
            R_PASSED=0; R_FAILED=0; R_UNKNOWN=0
            if [ -f "$RESULT_FILE" ] && [ -s "$RESULT_FILE" ]; then
              R_PASSED=$(jq '[.results[] | select(.result == "Passed")] | length' "$RESULT_FILE" 2>/dev/null) || R_PASSED=0
              R_FAILED=$(jq '[.results[] | select(.result == "Failed")] | length' "$RESULT_FILE" 2>/dev/null) || R_FAILED=0
              R_UNKNOWN=$(jq '[.results[] | select(.result == "Unknown")] | length' "$RESULT_FILE" 2>/dev/null) || R_UNKNOWN=0
            fi
            R_TOTAL=$((R_PASSED + R_FAILED + R_UNKNOWN))
            [ "$R_TOTAL" -eq 0 ] && R_TOTAL=35
            R_PCT=0
            [ "$R_TOTAL" -gt 0 ] && R_PCT=$((R_PASSED * 100 / R_TOTAL))

            {
              echo "### ${REPO_SHORT} — ${R_PASSED}/${R_TOTAL} passed (${R_PCT}%)"
              echo ""
            } >> /tmp/cis-dashboard.md

            if [ -f "$RESULT_FILE" ] && [ -s "$RESULT_FILE" ]; then
              {
                echo "| ID | Control | Result | Reason |"
                echo "|:---|:--------|:------:|:-------|"
                jq -r '
                  .results[] |
                  .id as $id | .name as $name | .reason as $reason |
                  if .result == "Passed" then
                    "| \($id) | \($name) | Pass | |"
                  elif .result == "Failed" then
                    "| \($id) | \($name) | Fail | \($reason // "") |"
                  else
                    "| \($id) | \($name) | Unknown | \($reason // "") |"
                  end
                ' "$RESULT_FILE" 2>/dev/null || echo "*(JSON parsing failed — see scan log artifact)*"
              } >> /tmp/cis-dashboard.md
            else
              echo "*(No results — chain-bench may have failed. See scan log artifact.)*" >> /tmp/cis-dashboard.md
            fi

          done < /tmp/repo-list.txt

          # Footer
          {
            echo ""
            echo "---"
            echo "<sub>Scanned by <a href=\"https://github.com/aquasecurity/chain-bench\">chain-bench</a> v${{ inputs.chain_bench_version }} via <a href=\"https://github.com/PavelGuzenfeld/standard\">standard</a></sub>"
          } >> /tmp/cis-dashboard.md

          cat /tmp/cis-dashboard.md >> "$GITHUB_STEP_SUMMARY"

          # Save outputs for threshold check
          echo "repo_count=$REPO_COUNT" >> "$GITHUB_OUTPUT"
          echo "avg_percent=$AVG_PERCENT" >> "$GITHUB_OUTPUT"
          echo "worst_score=$WORST_SCORE" >> "$GITHUB_OUTPUT"

          if [ -n "$FAILING_REPOS" ]; then
            echo "failing=true" >> "$GITHUB_OUTPUT"
          else
            echo "failing=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Upload scan results
        if: always()
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4
        with:
          name: cis-org-compliance
          path: |
            /tmp/cis-results/
            /tmp/cis-dashboard.md
            /tmp/repo-list.txt
          retention-days: 90
        continue-on-error: true

      - name: Create/update tracking issue
        if: always() && inputs.create_tracking_issue
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token || secrets.scan_token || github.token }}
        run: |
          ORG="${{ inputs.org }}"
          ISSUE_TITLE="CIS Supply Chain Compliance Dashboard"
          ISSUE_REPO="${ORG}/.github"

          BODY=$(cat /tmp/cis-dashboard.md)
          BODY="${BODY}"$'\n\n'"_Last updated: $(date -u '+%Y-%m-%d %H:%M UTC') | [Workflow run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})_"

          # Find existing issue
          ISSUE_NUM=$(gh issue list --repo "$ISSUE_REPO" --search "\"${ISSUE_TITLE}\" in:title" --state open --json number --jq '.[0].number' 2>/dev/null || echo "")

          if [ -n "$ISSUE_NUM" ]; then
            gh issue edit "$ISSUE_NUM" --repo "$ISSUE_REPO" --body "$BODY"
            echo "Updated issue #${ISSUE_NUM}"
          else
            gh issue create --repo "$ISSUE_REPO" \
              --title "$ISSUE_TITLE" \
              --body "$BODY" \
              --label "compliance" || true
            echo "Created new tracking issue"
          fi

      - name: Check threshold
        if: inputs.min_score > 0
        run: |
          if [ "${{ steps.dashboard.outputs.failing }}" = "true" ]; then
            echo "::error::One or more repos scored below the minimum threshold of ${{ inputs.min_score }}/35"
            exit 1
          fi
          echo "All repos meet the minimum threshold of ${{ inputs.min_score }}/35"
